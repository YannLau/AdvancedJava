# 原型模式

## 传统的方式的优缺点

1）优点是比较好理解，简单易操作。

2）在创建新的对象时，总是需要重新获取原始对象的属性，如果创建的对象比较复杂时，效率较低

3）总是需要重新初始化对象，而不是动态地获得对象运行时的状态，不够灵活

4）改进的思路分析

思路：Java中Object类是所有类的根类，Object类提供了一个clone()方法，该方法可以将一个Java对象复制一份，但是需要实现clone的Java类必须要实现一个接口Cloneable，该接口表示该类能够复制且具有复制的能力=＞原型模式

## 原型模式-基本介绍

基本介绍

1）原型模式（Prototype模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象

2）原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节

3）工作原理是：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 `对象.clone()`

4）形象的理解：孙大圣拔出猴毛，变出其它孙大圣

<img src="/Users/yannlau/Documents/JavaSet/Java韩顺平/高阶专题/设计模式专题/尚硅谷Java设计模式（图解+框架源码剖析）-HSP/assets/QQ_1726704488233.png" alt="QQ_1726704488233" style="zoom:50%;" />

<img src="/Users/yannlau/Documents/JavaSet/Java韩顺平/高阶专题/设计模式专题/尚硅谷Java设计模式（图解+框架源码剖析）-HSP/assets/QQ_1726705181684.png" alt="QQ_1726705181684" style="zoom:50%;" />

>  @HotSpotIntrinsicCandidate    protected native Object clone() throws CloneNotSupportedException; 为什么必须要实现Cloneable接口才能调用该方法，而equals，hashCode等方法不需要，从语法上来说是怎么实现的？
>
> ChatGPT 说：
>
> ChatGPT
>
> 在 Java 中，`clone()` 方法与 `equals()` 和 `hashCode()` 的设计有一些根本上的不同，主要体现在 `clone()` 的使用涉及到对象的浅拷贝或深拷贝，因此为了保证安全性和一致性，Java 语言规定 `clone()` 方法的调用必须要满足一定条件，比如实现 `Cloneable` 接口。这与 `equals()` 和 `hashCode()` 的行为不同。以下是它们在语法设计上的区别：
>
> ### 1. **`clone()` 方法的特殊性**
>
> `clone()` 是 `Object` 类的一个 **native 方法**，用于生成当前对象的副本（浅拷贝）。但是，默认情况下，`Object` 类的 `clone()` 方法会抛出 `CloneNotSupportedException`，除非该对象实现了 `Cloneable` 接口。
>
> 这是因为 `clone()` 涉及对象的低级别操作，直接拷贝对象的字段。出于设计上的考虑，Java 规定只有那些显式实现了 `Cloneable` 接口的类，才允许调用 `clone()` 方法。这是一种 **“标记接口”** 的用法，标志着类允许被克隆。
>
> #### 语法上如何实现：
>
> - `Cloneable` 接口是一个 **标记接口**（没有任何方法），它只是告诉 JVM 当前类的对象是可以被安全克隆的。
> - `Object` 类中的 `clone()` 方法首先检查对象是否实现了 `Cloneable` 接口。如果没有实现，它会抛出 `CloneNotSupportedException`。
>
> **简化的实现逻辑可以如下表示：**
>
> ```
> java
> 
> 
> 复制代码
> protected native Object clone() throws CloneNotSupportedException;
> 
> public Object clone() throws CloneNotSupportedException {
>     if (!(this instanceof Cloneable)) {
>         throw new CloneNotSupportedException();
>     }
>     return super.clone();  // native method, creates a copy of the object
> }
> ```
>
> ### 2. **`equals()` 和 `hashCode()` 的设计**
>
> 与 `clone()` 不同，`equals()` 和 `hashCode()` 这两个方法在 `Object` 类中都有默认实现，不依赖任何接口的实现：
>
> - `equals()` 默认是基于对象的引用比较，如果两个对象的引用相同，返回 `true`，否则返回 `false`。
> - `hashCode()` 默认返回的是基于对象内存地址计算出来的哈希码。
>
> #### 为什么不需要实现特定接口：
>
> - `equals()` 和 `hashCode()` 的默认行为是完全可以工作的，适用于大多数对象。
> - 如果你想要自定义 `equals()` 和 `hashCode()` 的行为（比如基于字段比较，而不是引用比较），可以覆盖这两个方法，但不需要实现任何额外的接口。
>
> ### 3. **设计上的原因**
>
> - **安全性**：`clone()` 操作需要明确标记，因为克隆对象涉及复制对象的字段、资源、引用等，可能产生副作用。强制要求实现 `Cloneable` 接口可以避免未经授权的对象被复制，从而确保对象在设计时可以被安全地克隆。
> - **一致性**：`equals()` 和 `hashCode()` 方法是关于对象比较的逻辑，默认实现已经足够，但克隆则属于特殊操作，需要类显式表明它支持这种行为。
>
> 因此，从语法设计角度来看，Java 使用 `Cloneable` 接口作为一种标记机制，来确保 `clone()` 操作的安全和一致性，而 `equals()` 和 `hashCode()` 是面向所有对象的通用方法，不需要类似的限制。

## 深入讨论-浅拷贝和深拷贝

### 浅拷贝的介绍

1）对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。

2）对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值

3）前面我们克隆羊就是浅拷贝

4）浅拷贝是使用默认的clone()方法来实现sheep = (Sheep) super.clone();

### 深拷贝基本介绍
1）复制对象的所有基本数据类型的成员变量值

2）为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝

3）深拷贝实现方式1：重写clone方法来实现深拷贝

4）深拷贝实现方式2：通过对象序列化实现深拷贝




//深拷贝 - 方式1使用clone 方法

//深拷贝 - 方式2通过对象的序列化实现（推荐）

<img src="/Users/yannlau/Documents/JavaSet/Java韩顺平/高阶专题/设计模式专题/尚硅谷Java设计模式（图解+框架源码剖析）-HSP/assets/QQ_1726707952663.png" alt="QQ_1726707952663" style="zoom:50%;" />

## 原型模式的注意事项和细节
原型模式的注意事项和细节

1）创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率

2）不用重新初始化对象，而是动态地获得对象运行时的状态

3）如果原始对象发生变化（增加或者減少属性），其它克隆对象的也会发生相应的变化，无需修改代码

4）在实现深克隆的时候可能需要比较复杂的代码

5）缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了ocp原则，这点请同学们注意.